\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{amsfonts, amsmath, amssymb}
\usepackage[none]{hyphenat}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{float}
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian,english]{babel}
\usepackage[nottoc, notlot, notlof]{tocbibind}
\usepackage[colorlinks,urlcolor=blue]{hyperref}
\usepackage{xcolor}
%\renewcommand{\rmdefault}{ftm} % Times New Roman
\frenchspacing
\linespread{1.3}
\usepackage{geometry}
\geometry{left=3cm}
\geometry{right=1.5cm}
\geometry{top=2.4cm}
\geometry{bottom=2.4cm}
\renewcommand\contentsname{Содержание}

\begin{document}
\selectlanguage{russian}
\setcounter{page}{2}
\renewcommand{\contentsname}{Содержание}
\tableofcontents

\newpage


\section{Введение}
В последние годы было проведено значительное количество исследований квантовых \sloppy компьютеров-машин, использующих квантовомеханические явления для решения математических задач, которые являются трудными или трудноразрешимыми для обычных компьютеров. Если крупномасштабные квантовые компьютеры когда-либо будут построены, они смогут сломать многие из криптосистем с открытым ключом, используемых в настоящее время. Это нанесет серьезный ущерб конфиденциальности и целостности цифровой связи в Интернете и в других местах.  Цель постквантовой криптографии (также называемой квантостойкой криптографией) заключается в разработке криптографических систем, защищенных как от квантовых, так и от классических компьютеров и способных взаимодействовать с существующими коммуникационными протоколами и сетями. 

Вопрос о том, когда будет построен крупномасштабный квантовый компьютер, является сложным. В то время как в прошлом было менее ясно, что большие квантовые компьютеры являются физической возможностью, многие ученые теперь считают, что это просто значительный инженерный вызов. Некоторые инженеры даже предсказывают, что в течение следующих двадцати или около того лет будут построены достаточно большие квантовые компьютеры, чтобы сломать практически все используемые в настоящее время схемы открытых ключей. Исторически сложилось так, что потребовалось почти два десятилетия, чтобы развернуть нашу современную инфраструктуру криптографии с открытым ключом.  Поэтому, независимо от того, можем ли мы оценить точное время прихода эпохи квантовых вычислений, мы должны начать сейчас готовить наши системы информационной безопасности, чтобы быть в состоянии противостоять квантовым вычислениям.
На сегодняшний день организация NIST (The National Institute of Standards and Technology)
инициировала процесс запроса, оценки и стандартизации одного или нескольких криптографических алгоритмов с открытым ключом с квантовой устойчивостью.

Одной из них является криптосистема Мак-Элиса, рассматриваемая как одна из альтернатив классическим криптосистемам.

\newpage
\section{Цель работы}

Целью данной работы является построить КНФ по ключу криптосистемы McEliece с QC-MDPC кодами, предложенной авторами [1], используя методы языка программирования Python 3. Для его дальнейшей факторизации при помощи SAT-решателей.  

\newpage

\section{Базовые сведения из терии кодирования и криптографии}
\normalsize
\textbf{Определение 1 (Расстояние Хэмминга и вес).}\\ Вес Хэмминга (или просто вес) вектора $x \in F_{2}^{n}$ это число ненулевых компонентов $wt(x)$.\\

\textbf{Определение 2 (Линейный код).}\\ Бинарный $(n,r)$-линейный код \textit{С} длины $\textit{n}$, размерности $\textit{n-r}$ соразмерности $r$, это $(n - r)$-размерный вектор подпространства $F_{2}^{n}$. Он охватывает строки матрицы $G \in F_{2}^{(n-r)\times n}$, называемая матрица-генератор $C$. Эквивалентно, это ядро матрицы $H \in F_{2}^{r\times n}$, называется матрицей проверки на четность $C$. Кодовое слово $c \in C$ вектора $m \in F_{2}^{(n-r)}$, где $c = mG$. Синдром $s \in F^{r}_{2}$ вектора $e \in F^{n}_{2}$, $s = He^{T}$. $C^{\perp} из С$ - это линейный код, охватываемый строками любой матрицы проверки на четность $C$.\\

\textbf{Определение 3 (Квазициклический код).} $(n,r)$ - линейный код является \sloppy квазициклическим, если существует некоторое целое число $n_{0}$ такое, что каждый циклический сдвиг кодового слова на $n_{0}$ мест снова является кодовым словом.  \\

\textbf{Определение 4 (LDPC/MDPC коды).}\\
$(n,r,w)$ - LDPC или MDPC код - это линейный код длины $n$, соразмерности $r$, которая допускает матрицу проверки на четность с постоянным весом w.

\textbf{Определение 5 (Циркулянт).}\\
Циркулянт - это матрица вида 
\begin{center}
\[ \begin{pmatrix}
a_{1} & a_{2} & \dots & a_{n} \\
a_{n} & a_{1} & \dots & a_{n - 1} \\
\vdots & \vdots & \vdots & \vdots \\
a_{2} & a_{3} & \dots & a_{1}
\end{pmatrix}
\]
\end{center}
\newpage
\textbf{Определение 6 (Конъюнкция).}\\
Логическая операция соответсвует союзу "и" и обозначается знаком $\wedge$, обозначает логическое умножение
\\
Конъюнкция двух булевых переменных - истина тогда и только тогда, когда оба высказывания истинны.

\begin{center}
\begin{tabular}[t]{|p{1em}|p{1em}|p{3em}|}
\hline
 $x_{1}$ & $x_{2}$ & $x_{1}\wedge x_{2}$ \\
\hline
 0 & 0 & 0 \\
\hline
 0 & 1 & 0 \\
\hline
 1 & 0 & 0 \\
\hline
 1 & 1 & 1 \\
\hline
\end{tabular}

\end{center}

\textbf{Определение 7 (Дизъюнкция).}\\
Логическая опрация соответсвует союзу "или", обозначается знаком $\vee$, обозначает логическое сложение
\\
Дизъюнкция двух логических переменных ложна тогда и толко тогда, когда оба высказывания ложны

\begin{center}
\begin{tabular}[t]{|p{1em}|p{1em}|p{3em}|}
\hline
 $x_{1}$ & $x_{2}$ & $x_{1}\wedge x_{2}$ \\
\hline
 0 & 0 & 0 \\
\hline
 0 & 1 & 1 \\
\hline
 1 & 0 & 1 \\
\hline
 1 & 1 & 1 \\
\hline
\end{tabular}

\end{center}

\textbf{Определение 8 (\textbf{Инверсия}).}\\
Логическая операция соответсвует частице "не", обозначается $\bar{x}$ и является логический отрицанием
\\ 
Инверсия логической переменной истинна, если переменная ложна и наоборот

\begin{center}
\begin{tabular}[t]{|p{1em}|p{1em}|}
\hline
 $x$ & $\bar{x}$ \\
\hline
 0 & 1 \\
\hline
 1 & 0 \\
\hline
\end{tabular}

\end{center}

\newpage
\textbf{Определение 9 (КНФ).}\\
Конъюнктивная нормальная форма(КНФ) в булевой логике - нормальная форма, в которой булева формула имеет вид конъюнкции дизъюнкций литералов. Конъюнктивная нормальная форма удобна для автоматического доказательства теорем. Любая булева формула может быть приведена к КНФ.

\newpage

\section{Криптосистема McEliece}



\subsection{Определение}

Для безопасной передачи секретных ключей пользователей в криптографических протоколах широко используется асимметричная криптография, основу которой составляют криптосистемы с открытым ключом. Криптосистема Мак-Элиса~--- это одна из старейших криптосистем с открытым ключом. Она была предложена в 1978 году Р.Дж.~Мак-Элисом. Основная идея построения этой криптосистемы состоит в маскировке некоторого линейного кода, имеющего эффективные алгоритмы декодирования, под код, не обладающий видимой алгебраической и комбинаторной структурой. Такие коды принято называть кодами общего положения. Предполагается, что декодирование кода общего положения является вычислительно трудной задачей. Следует отметить, что отсутствие эффективных квантовых алгоритмов декодирования кода общего положения делает криптосистему Мак-Элиса важной альтернативой таким криптосистемам, как криптосистема RSA и криптосистема Эль-Гамаля, которые получили широкое практическое применение, но при этом они станут бесполезными в постквантовую эру. Кодовые криптосистемы обладают одним недостатком, который не позволяет их использовать в устройствах с ограниченными ресурсами. У криптосистемы Мак-Элиса достаточно большая длина ключа. Классическая криптосистема Мак-Элиса строится на основе двоичных неприводимых кодов Гоппы. Для генерации таких кодов необходимо порождать неприводимые многочлены над расширениями конечных полей. Эта задача решается сравнительно медленно и значительное количество ресурсов. Кроме того, для декодирования неприводимых кодов Гоппы применяется алгоритм Паттерсона. Известно, что в этом случае на криптосистему Мак-Элиса возможны атаки по побочным каналам. 

В работе [5] предлагается два новых варианта кодов для криптосистемы - MDPC
(Разреженные коды проверки на четность) и QC-MDPC(Квазициклические разреженные коды проверки на четность).  
\begin{center}
\newpage
\textit{Ниже приведена таблица соответствия параметров, синдрома и размера ключа}\\
\begin{tabular}[t]{|p{6em}|p{1em}|p{3em}|p{3em}|p{3em}|p{3em}|p{5em}|}
\hline
Уровень безопасности & $n_{0}$ & $n$ & $r$ & $w$ & $t$ & QC-MDPC key-size\\
\hline
\hline
 80 & 2 & 9602 & 4801 & 90 & 84 & 4801 \\
\hline
 80 & 3 & 10779 & 3593 & 153 & 53 & 7186 \\
\hline
 80 & 4 & 12316 & 3079 & 220 & 42 & 9237 \\
\hline
\hline
 128 & 2 & 19714 & 9857 & 142 & 134 & 9857 \\
\hline
 128 & 3 & 22299 & 7433 & 243 & 85 & 14866 \\
\hline 
 128 & 4 & 27212 & 6803 & 340 & 68 & 20409 \\
\hline 
\hline
 256 & 2 & 65542 & 32771 & 274 & 264 & 32771 \\
\hline
 256 & 3 & 67593 & 22531 & 465 & 167 & 45062 \\
\hline 
 256 & 4 & 81932 & 20483 & 644 & 137 & 61449 \\
\hline
\end{tabular}
\end{center}

\begin{center}
\textit{Ниже приведена таблица соответсвия размеров ключей разных кодов}
\begin{tabular}[t]{|p{6em}|p{6em}|p{6em}|p{6em}|p{6em}|}
\hline
Уровень безопасности & QC-MDPC & QC-LDPC & QD-Goppa & Goppa \\
\hline
\hline
80 & 4801 & 12096 & 20480 & 460647 \\
\hline
128 & 9857 & - & 32768 & 1 537 536 \\
\hline
256 & 4801 & 12096 & 20480 & 7 667 855 \\
\hline
\end{tabular}
\end{center}
\subsection{MDPC/QC-MDPC варианты криптосистемы Mceliece}

В этом разделе мы рассмотрим конструкции MPDC и QC-MDPC кодов и опишем криптосистему.

\subsubsection{(n,r,w)-MDPC конструкция}

Случайный (n,r,w)-MDPC код легко генерируется выбором случайной матрицы проверки на четность $H \in F^{r \times n}_{2}$ с весом строки w. С высокой вероятностью эта матрица имеет полный ранг а самый правый блок $r \times r$ всегда обратим после возможной замены нескольких столбцов.

\newpage

\subsubsection{(n,r,w)-QC-MDPC конструкция}

В этой конструкции $n = n_{0}p и r = p$. Это означает, что матрица проверка на четность имеет вид\\
\begin{center}
$H = [H_{0}|H_{1}| . . . |H_{n_{0}-1}]$
\end{center}
где $H_{i}$ это $p \times p$  циркулянт.
Определим первую строку H, выбирая случайный вектор длины $n = n_{0}p$ и веса w. Другие $r - 1$ строки получены из квазициклических сдвигов первой строки. Каждый блок $H_{i}$ будет иметь вес строки w, такой, что  $ w = \sum\nolimits_{i=0}^{n_{0}-1} w_{i}$. 

Пораждающую матрицу G легко вывести от блоков $H_{i}$. Если правый блок $H_{n_{0} - 1}$ является нелинейным ($w_{n{0} - 1}$ - нечетно), мы строим порождающую матрицу следующим образом.

\begin{center}
\textbf{$ G = [I|Q] $} \\
\end{center}
Где I - единичная матрица, а \[ 
Q = \begin{bmatrix}  (H^{-1}_{n_{0}-1}\cdot H_{0})^{T}\\(H^{-1}_{n_{0}-1}\cdot H_{1})^{T}\\ \vdots \\ (H^{-1}_{n_{0}-1}\cdot H_{n_{0}-2})^{T} \end{bmatrix}
\]

\subsubsection{MDPC и QC-MDPC вариант}

\begin{enumerate}
\item{\textit{Генерация ключа}}
\begin{enumerate}
    \item Генерируется матрица проверки на четность $H \in F^{r\times n}_{2}$, $(n,r,w)$ - MDPC или $(n,r,w)$ - QC-MDPC код, исправляющий t ошибок
    \item Генерируется порождающая матрица $G \in F_{2}^{(n-r)\times n}$
\end{enumerate}
G - Открытый ключ, H - закрытый ключ
\item{\textit{Шифрование.}} Для шифрования текста $m \in F^{(n-r)}_{2}$ в $x \in F^{n}_{2}$:
\begin{enumerate}
	\item Генерируется случайный вектор $e \in F_{2}^{n}$, такой, что $wt(e) \leq t$
	\item Высчитывается $x \longleftarrow mG + e$
\end{enumerate}
\item \textit{Расшифрование.} Пусть $\Psi_{H}$ - алгоритм декодирования LDPC (Low density parity check code) с исправлением t - ошибок  
\begin{enumerate}
	\item Высчитывается $mG \longleftarrow 
\Psi_{H}(mG+e)$.
	\item Извлекаем открытый текст m из первых $(n-r)$ позиций mG. 
\end{enumerate}
\end{enumerate}

\subsection{Реализация алгоритма генерации ключей}

Реализация алгоритмов представлена на языке Python 3. Осуществлен процесс генерации секретного и открытого ключей. 

\subsubsection{Генерация секретного ключа}

Генерация секретного ключа включает в себя генерацию вектора $h_{i} \in F_{2}^{r}$, веса w. Генерация происходит при помощи модуля \textbf{random} и его метода \textbf{sample} который случайно выбирает индексы для единиц. После все остальные $(r-1)$ строки получаются цикличесик сдвигом. Далее все $(r\times r)$ матрицы конкатенируются в одну 
\begin{center}
$H = [H_{0}|H_{1}| . . . |H_{n_{0}-1}]$
\end{center}

В Приложении 1 представлен код на Python3, реализующий вышеописанный алгоритм.

\subsubsection{Генерация открытого ключа}

Открытый ключ представляет собой конкатенацию единичной матрицы и матрицы Q, имеющей вид 
\[ 
Q = \begin{bmatrix}  (H^{-1}_{n_{0}-1}\cdot H_{0})^{T}\\(H^{-1}_{n_{0}-1}\cdot H_{1})^{T}\\ \vdots \\ (H^{-1}_{n_{0}-1}\cdot H_{n_{0}-2})^{T} \end{bmatrix}
\]

Наиболее проблемная часть - нахождение обратной двоичной матрицы матрицы.

В Приложении 2 представлен код на Python3, реализующий вышеописанный алгоритм.

\newpage

\subsubsection{Особенности реализации}

Программа написана на языке Python 3 с использованием модулей random и numpy. Данные в программе хранятся в типе numpy.matrix() - для работы с матрицами. Подмножество методов numpy.linalg. - содержит большое количество оперций с матрицами (Умножение, транспонирование, и т.д.)
Для нахождения обратных бинарных матриц был разработан класс бинарных матриц на языке Python3, в котором реализованы такие операции, как:

\begin{enumerate}

\item Нахождение ранга бинарной матрицы
\item Вычисление определителя 
\item Нахождение обратной матрицы

\end{enumerate}

\newpage

\section{Построение эквивалентной КНФ}

Пусть имеется система линейных уравнений

\[
\begin{cases}
h_{1}^{1}e_{1}\oplus h_{2}^{1}e_{2}\oplus ... \oplus h_{n}^{1}e_{n} = b_{1};  \\
h_{1}^{2}e_{1}\oplus h_{2}^{2}e_{2}\oplus ... \oplus h_{n}^{2}e_{n} = b_{2};  \\
\dots \\
h_{1}^{m}e_{1}\oplus h_{2}^{m}e_{2}\oplus ... \oplus h_{n}^{m}e_{n} = b_{m};  \\
\end{cases}
\]

что равносильно:

\[
\begin{cases}
h_{1}^{1}e_{1}\oplus h_{2}^{1}e_{2}\oplus ... \oplus h_{n}^{1}e_{n} \oplus b_{1}
\oplus 1 = 1;  \\
h_{1}^{2}e_{1}\oplus h_{2}^{2}e_{2}\oplus ... \oplus h_{n}^{2}e_{n} \oplus b_{2} \oplus 1 = 1;  \\
\dots \\
h_{1}^{m}e_{1}\oplus h_{2}^{m}e_{2}\oplus ... \oplus h_{n}^{m}e_{n} \oplus b_{m} \oplus 1 = 1;  \\
\end{cases}
\]

Рассмотрим первое уравнение в системе:

\begin{center}
$h_{1}^{1}e_{1}\oplus h_{2}^{1}e_{2}\oplus ... \oplus h_{n}^{1}e_{n} \oplus b_{1}
\oplus 1 = 1.$
\end{center}

Рассмотрим ее в виде функции от n переменных:

\begin{center}
$f_{1}(e_{1},e_{2},...,e_{n}) = h_{1}^{1}e_{1}\oplus h_{2}^{1}e_{2}\oplus ... \oplus h_{n}^{1}e_{n} \oplus b_{1}
\oplus 1$
\end{center}

Функция $f_{1}(e_{1},e_{2},...,e_{n})$ принимает значение 1 на тех наборах, которые удовлетворяют первому уравнению системы. Следовательно задачу решения этого уравнения можно свести к задаче выполнимости ФАЛ $f_{1}(e_{1},e_{2},...,e_{n})$

Интуитивный метод представления афинной функции от n переменных в виде КНФ, заключающийся в перечислении всех векторов длины $n$ и проверке каждого уравнения на равенство, имеет сложность $2^{n}$ и не представляет интереса. В статье [5] описан метод, позволяющий с линейной сложностью получить КНФ афинной функции. Рассмотрим некоторую сумму n переменных:

\begin{center}
$a_{1} \oplus a_{2} \oplus ... \oplus a_{n} = b_{n}$
\end{center}
\newpage

Данное уравнение равносильно системе: 

\[
\begin{cases}
a_{1} \oplus a_{2} \oplus a_{3} \oplus y_{1} = b_{1}; \\
y_{1} \oplus a_{4} \oplus a_{5} \oplus y_{2} = b_{2}\\
\dots \\
y_{\frac{n-4}{2}} \oplus a_{n - 2} \oplus a_{n - 1} \oplus a{n} = b_{\frac{n-4}{2} + 1}\\
\end{cases}
\]

Где $y_{i}, i = 1...\frac{n-4}{2}$ - дополнительные переменные, $b_{j}, j = 1...(\frac{n}{2} - 1)$ - некоторые константы, причем $ \sum_{j = 1}^{\frac{n}{2} - 1} b_{j} \equiv b$  mod 2. 
Каждое уравнение последней системы представляется в виде КНФ, состоящей из восьми элементарных дизъюнктов, каждый из которых состоит из четырех слагаемых. В итоге, при $ n \geq 6$ длина КНФ равна: 

\begin{center}
$ 32(\frac{n-4}{2} + 1) = 16n - 32$
\end{center}

Таким же образом можно представить каждое уравнение в виде КНФ. Обозначим КНФ i-го уравнение в системе как $K_{i}$. Получим:

\[
\begin{cases}
K_{1} = 1; \\
K_{2} = 1;\\
\dots \\
K_{m} = 1;\\
\end{cases}
\]

Что равносильно:
\begin{center}
$K = K_{1}K_{2}...K_{m} = 1$
\end{center}

Длина записи КНФ $K$ равна:
\begin{center}
$m \cdot (16n - 32) = 16mn - 32m.$
\end{center}

Полученная КНФ $K$ истинна при некотором значении вектора s:

\begin{center}
$s = (e_{1}, ... , e_{m}, y_{1}, ... , y_{\frac{n}{2} - 2})$,
\end{center}
Причем первые $m$ разрядов данного вектора являются решением системы уравнений

\[
\begin{cases}
h_{1}^{1}e_{1}\oplus h_{m+1}^{1}e_{m+1}\oplus ... \oplus h_{n}^{1}e_{n} \oplus b_{1}
\oplus 1 = 1;  \\
h_{2}^{2}e_{2}\oplus h_{m+1}^{2}e_{m+1}\oplus ... \oplus h_{n}^{2}e_{n} \oplus b_{2} \oplus 1 = 1;  \\
\dots \\
h_{m}^{m}e_{m}\oplus h_{m+1}^{m}e_{m+1}\oplus ... \oplus h_{n}^{m}e_{n} \oplus b_{m} \oplus 1 = 1;  \\
\end{cases}
\]


Таким образом мы доказали следующую теорему:

\newtheorem{Th}{Теорема}
\begin{Th}
Существует полиномиальный алгоритм сведения задачи решения системы линейных уравнений $He^{T} = b^{T}$, где $H$ - двоичная матрица $m\times n$, к задаче выполнимости КНФ, в которой $ m \cdot \frac{n-4}{2} + n$ переменных и $16m(n-2)$ элементарных дизъюнктов, в каждом из которых не более четырех слагаемых.
\end{Th}

Таким образом для построения эквивалентной КНФ нам потребуется секретный и открытый ключ. H - секретный ключ, G - открытый. Получаем систему уравнений 
\begin{center}
\textbf{$GH^{T} = 0$}
\end{center}



По данной системе мы и будем строить КНФ.
\\

Реализация на языке Python 3 в Приложении 4.
\newpage

\section{Концептуальная часть}

\subsection{Немного о SAT-solvers}

Приведем список задач, которые встречаются вокруг нас и как они связаны с SAT

\begin{itemize}
\item Алгоритм RSA, который используется для обеспечения безопасности банковских транзакций, для создания безопасного соединения и т.д. может быть взломан при помощи SAT	
\item Многие рекомендательные системы (например Netflix) используют алгоритм разложения булевых матриц для рекомендации контента. Оптимальное разложение таких матриц может быть найдено при помощи SAT.
\item NASA проверяет спецификации своего ПО и моделей своего технического обеспечения с помощью методов model checking, напрямую свзанного с SAT.
\item Задачи о сериализации истории транзакций в базах данных может быть решена с помощью SAT.
\end{itemize}

Проще говоря, если у нас есть эффективное решение задачи SAT, то мы можем решать все указанные задачи. Если известно эффективное решение задачи SAT, то мы можем эффективно решать любую задачу в классе NP. Иначе говоря, SAT — это задача представитель класса, она является «сложнейшей» в своем классе и позволяет решить все другие задачи в NP.

\subsection{Будущая работа}

Выше был описан метод построения эквивалентной КНФ. В последующей дипломной работе будет произведена работа с SAT-solvers. А именно с SAT - минимизаторами  (MiniSAT - решатель задач псевдо-булева программирования и минимизатор КНФ (CNF)), также задача факторизации будет решаться при помощи SAT.

В рамках дипломной работы также будет реализована криптосистема на языке \textbf{C}. 


\newpage

\section{Приложения}

\subsection{Приложение 1}
\begin{verbatim}
import random
import numpy as np
from binmatrix import BinMatrix
from functools import reduce

r = 4801
w = 45

once_range = [i for i in range(r+1)]   # For make random '1' sequence

while(1):
    weight_sequence = random.sample(once_range, w)   # Random index for 1

    H_first_row = []

    for i in range(r):
        if(i in weight_sequence):    # w = 90, make 90 '1'
            H_first_row.append(1)
        else:
            H_first_row.append(0)

    H0_matrix = [[] for i in range(r)]

    for i in range(r):
        H0_matrix[i] = H_first_row[i:] + H_first_row[:i]
    H0_matrix_m = H0_matrix
    H0_matrix = BinMatrix(H0_matrix)
    if(H0_matrix.det()):
        break


while(1):
    weight_sequence = random.sample(once_range, w)   # Random index for 1

    H_first_row = []

    for i in range(r):
        if(i in weight_sequence):
            H_first_row.append(1)
        else:
            H_first_row.append(0)

    H1_matrix = [[] for i in range(r)]

    for i in range(r):
        H1_matrix[i] = H_first_row[i:] + H_first_row[:i]
    H1_matrix_m = H1_matrix
    H1_matrix = BinMatrix(H1_matrix)
    print(H1_matrix.det())
    if(H1_matrix.det()):
        break

H = np.hstack((H0_matrix_m,H1_matrix_m))    # private key

\end{verbatim}

\subsection{Приложение 2}

\begin{verbatim}
import random
import numpy as np
from binmatrix import BinMatrix
from functools import reduce

H1_inverse_on_map = H1_matrix.inv()

H1_inverse = [[] for i in range(r)]

for i in range(len(H1_inverse_on_map)):
    for j in H1_inverse_on_map[i]:
        H1_inverse[i].append(j)

H1_inverse = np.array(H1_inverse)

H1_matrix_m = np.array(H1_matrix_m)

H0_matrix_m = np.array(H1_matrix_m)

Q_matrix = H1_inverse*H0_matrix_m

Q_matrix = Q_matrix.transpose()

# Make a diag matrix

pointer = 0
row_I = []
I = []

for i in range(r):     # Diag matrix
    for j in range(r):
        if j == pointer:
            row_I.append(1)
        else:
            row_I.append(0)
    I.append(row_I)
    pointer += 1
    row_I = []

I = np.matrix(I)

G = np.hstack((I,Q_matrix))   # Public key

print("""#*****\nPublic key (G,t), where t = 84, G = \n""")

print(G)
\end{verbatim}

\subsection{Приложение 3}
\begin{verbatim}

from functools import reduce

class DataError(Exception):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def printError(self):
        print("The element at [{0}][{1}] is 
        NOT binary!".format(self.x, self.y))

class FormatError(Exception):
    def __init__(self, s):
        self.error = "The input is " + s
    def printError(self):
        print(self.error)

class RankError(Exception):
    def __init__(self, r):
        self.r = r
    def printError(self):
        print("The matrix is NOT full rank. 
        (rank = {0})".format(self.r))

class Binary_Matrix:
    def __init__(self, m = [[1]]):
        self.m = m
        self.r_len = len(self.m) # row number
        self.c_len = len(self.m[0]) # column number

    def __convertMatrixToInt(self):
        return [int(reduce(lambda x , y: x + y, 
        map(str, self.m[i])), 2) for i in range(self.r_len)]

    def __appendUnitMatrix(self):
        m_int = self.__convertMatrixToInt()
        return [(1 << (self.r_len + self.c_len - 1 - i))
         ^ m_int[i] for i in range(self.r_len)]

    def __chooseElement(self, r, c, m_int):
        assert r <= c, "The row index can not exceed the
        column index in row-reduced echelon matrix."

        if c == self.c_len:
            return None
        else:
            mask = (1 << (self.c_len - 1 - c))
            temp = [(m_int[i] & mask) for i in 
            range(r, self.r_len)]
            if mask not in temp:
                return self.__chooseElement(r, c + 1, m_int)
            else:
                return (temp.index(mask) + r, c)

    @staticmethod
    def __switchRows(r1, r2, m_int):
        temp = m_int[r1]
        m_int[r1] = m_int[r2]
        m_int[r2] = temp

    def __addRows(self, r, c, m_int):
        mask = (1 << (self.c_len - 1 - c))
        it = list(range(self.r_len))
        it.remove(r)
        for i in it:
            if m_int[i] & mask != 0:
                m_int[i] ^= m_int[r]

	
    def __isMatrix(self):
        if [len(l) for l in self.m].count(self.c_len) != self.r_len:
            raise FormatError("NOT a matrix!")
        else:
            pass

    def __isSquareMatrix(self):
        if [len(l) for l in self.m].count(self.r_len) != self.r_len:
            raise FormatError("NOT a Square matrix!")
    else:
        pass

    def __isBinary(self):
        for i in range(len(self.m)):
            for j in range(len(self.m[i])):
                if self.m[i][j] not in [0,1]:
                    raise DataError(i, j)
                else:
                    pass

    def rank(self):
        self.__isMatrix()
        self.__isBinary()
        m_int = self.__convertMatrixToInt()
        r = 0
        c = 0
        for i in range(self.r_len):
            arg = self.__chooseElement(r, c, m_int)
            if arg != None:
                r_temp = arg[0]
                c = arg[1]
                self.__switchRows(r, r_temp, m_int)
                self.__addRows(r, c, m_int)
                r += 1
				c += 1
			else:
				return r
		return self.r_len

	def det(self):
		self.__isSquareMatrix()
		self.__isBinary()
		if self.rank() == self.r_len:
			return 1
		else:
			return 0

    def inv(self):
        self.__isSquareMatrix()
		self.__isBinary()
		m_adj = self.__appendUnitMatrix()
		r = 0
		c = 0
		for i in range(self.r_len):
			arg = self.__chooseElement(r, c, m_adj)
			if arg != None:
				r_temp = arg[0]
				c = arg[1]
				self.__switchRows(r, r_temp, m_adj)
				self.__addRows(r, c, m_adj)
				r += 1
				c += 1
			else:
				raise RankError(r)
		return [map(int, list(format((m_adj[i] >> self.c_len), "0" + 
		str(self.r_len) + "b"))) for i in range(self.r_len)]
\end{verbatim}

\subsection{Приложение 4}

\begin{verbatim}
CNF = ""

for i in range(r):
    CNF = CNF + '('
    for j in range(2*r):
        if(SLAU[i][j] != 0):
            CNF = CNF + "x" + str(j) + "V"
        else:
            CNF = CNF + "not(x)" + str(j) + "V"
    CNF = CNF + ')' + '&'

\end{verbatim}

\newpage

\begin{thebibliography}{00} % библиография
\bibitem{}
Э.Берлекэмп. Алгебраическая теория кодирования, Москва, Мир,
1971.
\bibitem{}
У.Питерсон, Э.Уэлдон. Коды, исправляющие ошибки, Москва, Мир,
1976.
\bibitem{}
Т.Касари, Н.Токура, Е.Ивадари, Я.Инагаки. Теория кодирования,
Москва, Мир, 1978.
\bibitem{}
R. J. McEliece. Public-Key System Based on Algebraic Coding Theory.
In DSN Progress Report 44, pages 114-116, Jet Propulsion Lab, 1978.
\bibitem{}
MDPC-McEliece: New McEliece Variants from
Moderate Density Parity-Check Codes
Rafael Misoczki1 and Jean-Pierre Tillich1 and
Nicolas Sendrier and Paulo S. L. M. Barreto
\end{thebibliography}

\end{document}
